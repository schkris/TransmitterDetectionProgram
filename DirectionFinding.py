import zmq
import numpy as np
import math

# Initialize ZMQ context and sockets
context = zmq.Context()

# Set up a PULL socket for each ZMQ PUSH source from GNURadio
nullPwr_socket1 = context.socket(zmq.SUB)
nullPwr_socket1.connect("tcp://localhost:5555")
nullPwr_socket1.setsockopt(zmq.SUBSCRIBE, b"")

sumPwr_socket2 = context.socket(zmq.SUB)
sumPwr_socket2.connect("tcp://localhost:5556")
sumPwr_socket2.setsockopt(zmq.SUBSCRIBE, b"")

frontAvg_socket3 = context.socket(zmq.SUB)
frontAvg_socket3.connect("tcp://localhost:5557")
frontAvg_socket3.setsockopt(zmq.SUBSCRIBE, b"")

backAvg_socket4 = context.socket(zmq.SUB)
backAvg_socket4.connect("tcp://localhost:5558")
backAvg_socket4.setsockopt(zmq.SUBSCRIBE, b"")


# Look Up Tables
angles = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90])
sum_diff_pattern = np.array([1.039678987951172e+16, 36.46833951239416, 18.22324029005969, 12.13668397291745, 9.089764476829286, 7.258700951464442, 6.035566765644261, 5.159822222891488, 4.501197743285386, 3.987321593417447, 3.574770980811172, 3.235913462727591, 2.952327652667128, 2.711260525844071, 2.50360302418306, 2.322675421095891, 2.163468176169271, 2.022150725127745, 1.89574400805255, 1.781896411266312, 1.678726928129285, 1.584713132469814, 1.498609706107719, 1.41938822142021, 1.346191979581296, 1.278301688901115, 1.2151090647881, 1.156096297587319, 1.100819921329007, 1.048898021097114, 1.000000000000001, 0.9538383277568345, 0.9101618374038304, 0.8687502417078927, 0.8294096181418369, 0.7919686686726374, 0.7562756036615973, 0.7221955317510095, 0.6896082624717756, 0.6584064474287512, 0.6284940007399294, 0.5997847509713355, 0.5722012858964555, 0.5456739585937432, 0.5201400291104901, 0.4955429204930148, 0.4718315716601727, 0.4489598725701771, 0.4268861695463496, 0.4055728305996544, 0.3849858622034651, 0.3650945703086991, 0.3458712594901843, 0.3272909650314084, 0.3093312135194426, 0.2919718081624512, 0.2751946355812698, 0.2589834912819189, 0.2433239214023425, 0.228203078655874, 0.2136095906757157, 0.1995334392069354, 0.1859658488016377, 0.1728991838544694, 0.1603268529737475, 0.1482432198220294, 0.1366435196817197, 0.1255237811089127, 0.1148807521340486, 0.1047118305527955, 0.0950149979262563, 0.08578875697717306, 0.07703207212922893, 0.06874431299048545, 0.06092520063008834, 0.05357475654000488, 0.04669325421116773, 0.04028117328623815, 0.03433915627949896, 0.02886796787840602, 0.02386845686113654, 0.01934152068036408, 0.01528807277549205, 0.01170901268398073, 0.008605199027297214, 0.005977425448675731, 0.003826399578492325, 0.002152725098910777, 0.0009568869728392005, 0.000239239893458156, 6.123233995736766e-17])
diff_sum_pattern = np.array([9.618353468608949e-17,0.02742104558010214,0.05487498293843353,0.08239482895257567,0.1100138515743834,0.1377656975657952,0.1656845229005193,0.1938051267664828,0.2221630901445597,0.2507949199911216,0.2797382001162727,0.3090317499272949,0.3387157922992055,0.3688321319430118,0.3994243457691564,0.4305379868910729,0.4622208040844135,0.4945229787145698,0.5274973813723272,0.5611998507193502,0.5956894973468766,0.6310290357987225,0.6672851483107375,0.7045288842818639,0.7428361000271507,0.782287943982648,0.8229713932505207,0.8649798482072129,0.9084137928687842,0.9533815298402715,0.9999999999999992,1.048395698620882,1.098705701452421,1.151078816431844,1.205676879224459,1.262676213790161,1.322269282730241,1.384666556403964,1.450098634862177,1.51881866270487,1.591105084253302,1.667264795212827,1.747636757637343,1.83259615792753,1.922559203355557,2.017988671909795,2.119400353989517,2.227370553798635,2.342544854668626,2.465648397900478,2.59749798155315,2.739016357198816,2.891249193338597,3.055385289673472,3.23278077444049,3.424988207914946,3.633791763010884,3.861249977943345,4.109748002731197,4.382061827956237,4.681437742737481,5.011691293322036,5.3773314102777,5.783717295286413,6.237258334782779,6.745671074876348,7.318312660046189,7.966617888385105,8.704678385402193,9.550019274047571,10.52465423170484,11.65653909947761,12.98160587349125,14.54665784700481,16.41356925636685,18.66550712653801,21.41636981388262,24.8254933612285,29.12127461317436,34.64047085725164,41.8962987769953,51.70224288595991,65.41046832293188,85.4042972699239,116.2088171148422,167.2961057542834,261.3422826044789,464.5274961052731,1045.055506433407,4179.904887705962,1.633123935319537e+16,])
sum_minus_diff = np.array([160.1689926691228,15.6191598933457,12.6062560177935,10.84100043495017,9.58552630445449,8.6085890443414,7.807180584656003,7.126347386529323,6.533280924610887,6.006812646601727,5.532482237718073,5.099968988603788,4.701645543193102,4.331712510737477,3.985654674799252,3.659885241885864,3.351505112677089,3.058135234862582,2.7777969197031,2.508824531671472,2.249800569172816,1.999506569253716,1.756885410842979,1.521011969803475,1.291069987642111,1.066333627133961,0.8461526074079013,0.6299401035524868,0.4171628030729295,0.2073326605083847,3.33066907387547e-15,-0.2052523044601662,-0.4088137818184745,-0.6110506157030229,-0.8123093270276267,-1.012919993344163,-1.213199090790177,-1.413452028960149,-1.613975436966814,-1.815059249570576,-2.016988634958901,-2.220045800122858,-2.424511705483944,-2.630667717233614,-2.838797223588997,-3.049187239718158,-3.262130025367905,-3.477924739190114,-3.696879154396748,-3.919311461694539,-4.145552187506128,-4.375946258355508,-4.610855246101,-4.850659833603805,-5.095762546644745,-5.346590805740545,-5.603600361347821,-5.867279188286826,-6.13815193073509,-6.416785008720602,-6.703792521863872,-6.999843117762534,-7.305668033023928,-7.622070567453772,-7.949937320336874,-8.290251607712285,-8.644109598967116,-9.012739871234494,-9.397527297295806,-9.800042480867889,-10.2220783678996,-10.66569624770357,-11.13328419649038,-11.62763223883285,-12.15203031984899,-12.7103979384792,-13.307458575598,-13.94897888060875,-14.64210379753419,-15.39583786616566,-16.22175658008613,-17.13509383555598,-18.15647258585213,-19.31479723542188,-20.65239080541844,-22.23485831762694,-24.17209679977005,-26.67011425656618,-30.19139357908841,-36.21166399666323,-162.1301914394243,])
diff_minus_sum = np.array([-160.1689926691228,-15.6191598933457,-12.6062560177935,-10.84100043495017,-9.58552630445449,-8.6085890443414,-7.807180584656003,-7.126347386529323,-6.533280924610887,-6.006812646601727,-5.532482237718073,-5.099968988603788,-4.701645543193102,-4.331712510737477,-3.985654674799252,-3.659885241885864,-3.351505112677089,-3.058135234862582,-2.7777969197031,-2.508824531671472,-2.249800569172816,-1.999506569253716,-1.756885410842979,-1.521011969803475,-1.291069987642111,-1.066333627133961,-0.8461526074079013,-0.6299401035524868,-0.4171628030729295,-0.2073326605083847,-3.33066907387547e-15,0.2052523044601662,0.4088137818184745,0.6110506157030229,0.8123093270276267,1.012919993344163,1.213199090790177,1.413452028960149,1.613975436966814,1.815059249570576,2.016988634958901,2.220045800122858,2.424511705483944,2.630667717233614,2.838797223588997,3.049187239718158,3.262130025367905,3.477924739190114,3.696879154396748,3.919311461694539,4.145552187506128,4.375946258355508,4.610855246101,4.850659833603805,5.095762546644745,5.346590805740545,5.603600361347821,5.867279188286826,6.13815193073509,6.416785008720602,6.703792521863872,6.999843117762534,7.305668033023928,7.622070567453772,7.949937320336874,8.290251607712285,8.644109598967116,9.012739871234494,9.397527297295806,9.800042480867889,10.2220783678996,10.66569624770357,11.13328419649038,11.62763223883285,12.15203031984899,12.7103979384792,13.307458575598,13.94897888060875,14.64210379753419,15.39583786616566,16.22175658008613,17.13509383555598,18.15647258585213,19.31479723542188,20.65239080541844,22.23485831762694,24.17209679977005,26.67011425656618,30.19139357908841,36.21166399666323,162.1301914394243,])

def process_mags(diff, sum, frontAvg, backAvg):
    # Calculate direction indicators
    direction_indicator_1 = sum / diff
    direction_indicator_2 = diff / sum

    # Reference Power
    ref_power = max(sum, diff)
    ref_power2 = (sum + diff) / 2

    # Normalize Differences
    sum_normalized = sum / ref_power
    diff_normalized = diff / ref_power2

    # Convert to dB
    sum_dB = 10 * np.log10(sum_normalized)
    diff_dB = 10 * np.log10(diff_normalized)

    # Calculate difference between the normalized values
    sum_diff = sum_dB - diff_dB
    diff_sum = diff_dB - sum_dB

    # Initialize variables to store the angles
    angle1 = None
    angle2 = None
    angle3 = None
    angle4 = None
    
    # Handle out-of-bounds values for direction_indicator_1
    if direction_indicator_1 >= sum_diff_pattern[1]:  # Larger than the second largest value
        angle1 = 0
    elif direction_indicator_1 <= sum_diff_pattern[-2]:  # Smaller than the second smallest value
        angle1 = 90
    
    # Handle out-of-bounds values for direction_indicator_2
    if direction_indicator_2 >= diff_sum_pattern[-2]:  # Larger than the second largest value
        angle2 = 90
    elif direction_indicator_2 <= diff_sum_pattern[1]:  # Smaller than the second smallest value
        angle2 = 0
    
    # Find the closest match in ratio patterns if angle1 or angle2 not already assigned
    if angle1 is None:
        idx1 = (np.abs(sum_diff_pattern - direction_indicator_1)).argmin()
        angle1 = angles[idx1]
    
    if angle2 is None:
        idx2 = (np.abs(diff_sum_pattern - direction_indicator_2)).argmin()
        angle2 = angles[idx2]

    # Find the closest match in ratio differences
    if angle3 is None:
        idx3 = (np.abs(sum_minus_diff - sum_diff)).argmin()
        angle3 = angles[idx3]
    
    if angle4 is None:
        idx4 = (np.abs(diff_minus_sum - diff_sum)).argmin()
        angle4 = angles[idx4]

    if backAvg > frontAvg:
        angle1 = 180 - angle1
        angle2 = 180 - angle2
        angle3 = 180 - angle3
        angle4 = 180 - angle4
    
    return [angle1, angle2, angle3, angle4]


def process_phase(phase_diff):
    angle = (phase_diff + math.pi) % (2 * math.pi) - math.pi
    angle = angle * 180 / math.pi
    return angle

# Main processing loop
while True:
    # Receive data from each antenna receiver
    nullPwrMag = np.frombuffer(nullPwr_socket1.recv(), dtype=np.float32)
    sumPwrMag = np.frombuffer(sumPwr_socket2.recv(), dtype=np.float32)
    #angle = np.frombuffer(angle_socket.recv(), dtype=np.float32)

    frontAvg = np.frombuffer(frontAvg_socket3.recv(), dtype=np.float32)
    backAvg = np.frombuffer(backAvg_socket4.recv(), dtype=np.float32)

    direction = process_mags(nullPwrMag[0], sumPwrMag[0], frontAvg[0], backAvg[0])
    #phase0 = process_phase(angle[0])

    '''
    # Process the averaged values directly
    direction = process_data(nullPwrMag[0], sumPwrMag[0])
    constant = 0 # math.acos(phase180)
    phaseDiff = (2 * phase0) / (magA * magB)
    phaseDiff = phaseDiff[0]
    phaseDiff180 = (2 * phase180) / (magA_180 * magB_180)
    phaseDiff180 = phaseDiff180[0]

    # Calculate phase difference
    phase0Degrees = phase0[0] * 180 / math.pi
    phase180Degrees = phase180[0] * 180 / math.pi
    phaseDiff180 = phaseDiff180 * 180 / math.pi
    phaseDiffDegrees = phaseDiff * 180 / math.pi
    '''

    # Output results
    print(f"Sum/Diff Direction indicator: {direction[0]}")
    print(f"Diff/Sum Direction indicator: {direction[1]}")
    print(f"Sum - Diff Direction: {direction[2]}")
    print(f"Diff - Sum Direction: {direction[3]}")
    # print(f"Phase: {phase0}")
    # print(f"0 Phase: {phaseDiff}")
    # print(f"180 Phase: {phaseDiff180} \n")
